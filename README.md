

Arcade Game Simulator

Теодора Павловска

1. Опис на апликацијата

Апликацијата која ја развив служи како симулатор на две класични игри

Трка со топчиња(Ball Race) и Икс-нула.(Tic Tac Toe).

Со цел да ги задоволиме различните играчи и корисници, игрите имплементираат

различни алгоритми соодветни за различните варијанти , нивното зачувување како и

податоци за највисоко стекнати поени, но во стилот на старите аркадни игри двете

платформи не дозволуваат долготрајно зачувуввање на податоците.

2. Упатство за користењe

2.1 Мени

![Слика 1](https://github.com/teodora-pavlovska/VP2023_FINAL/blob/master/image.png)

2.1.1 Ball Race

На почетниот прозорец (Слика 1) при стартување на апликацијата имаме можност да

избереме помееѓу две игри. Кога корисникот ќе избере една од нив се креира објект од

соодвентиот прозорец во кој што ќе се прикаже избранта игра (Објект кој наследува од

класата Forms).

![Слика 2](https://github.com/teodora-pavlovska/VP2023_FINAL/blob/master/image%20(1).png)

Кога ќе се вкличи Ball Race се покажува прозорец како тој прикажан во Слика 2 и на

играта има само едно копче Start. По започнувањето на играта почнува да тече

тајмерот,иако играта е базирана на игрите во форма на бесконечно трчање(Endless Runner

Games). Корисник губи кога ке истече тајмерот или пак кога ке се судри со некои од

другите топчиња.

2.1.2 Поени
![Слика 3](https://github.com/teodora-pavlovska/VP2023_FINAL/blob/master/image%20(2).png)

При секое вклучување на играта, кога играчот ќе изгуби добива известување за тоа колку

поени освоил, колку најмногу поени биле освоени и колку поени се добиени од

последното вклучување на играта.

2.1.3 Правила и општи информации за играта :

Играчот е топче со црвена боја и треба да избегнува судир со други топчиња.


Движечето на топчето се одвива на следниот начин ：



Копчето W се користи за движење право и за забрзување на топчето. Максимално

може да се забрза 3 пати пред да се врати на оргиналната брзина на движење.

Со копчето D може да го движите топчето надесно.

Со копчето А моше да го движите топчето налево.

Топчето на почетокот е црвено и се движи со случајно зададена брзина во однос на

типот на нивото.



Корисникот има право да избира помеѓу различни нивоа на тежина, но тоа може да

се направи се додека не е започната играта.


Корисникот има право да ја стопира играта.

Топчињата кои се во околина доколку се судрат и тие изчезнуваат од панелот.

Бојата на топчето може да биде подесена.

2.1.4 Претставување на проблемот

2.1.3.1 Road.cs

Road е класа која ја користиме да ја дефинираме патеката на која се движат топчињата чииј

ленти се одделени со две испрекинати вертикални линии. Лентата дава илузија на

движење со тоа што има одредена “брзина” на движење преку која се пресметува офсетот.

Офсетот ни помага со вертикално поместување на прекинатите линиии ,поточно со

самото нивно прецртување што даваат илузија дека патеката се движи.

2.1.3.2 Класа Ball.cs

Класата топка е класа која служи за креирање, цртање и контролирање на топчиња со

предходно познат радиус. Kласата во себе содржи неколку основни карактеристики и

булеанови променливи кои определуваат:



Центарот на топчето

Број за идентификација

Дали е главниот играч

Дали се судрило со друго копче

2.1.3.3 Canvas класата за исцртување

Canvas класата е класа која се користи за исцртување на патеката и на топките.

Таа ги содржи следните важни функции：



Функција за креирање на нови топчиња при почеток на секоја игра

Функција за преоверување на колизии како и за проверување дали се достигнати

терминални услови за играта (булева вредност на канвас колизија кога е вистинита)

Функција за отстранување на топки кои веќе биле во колизија


Функција за генерирање на нови топчиња за време на играта

2.2 Икс Нула
![Слика 3]( https://github.com/teodora-pavlovska/VP2023_FINAL/blob/master/image%20(4).png)

2.2.1 Општи правила и инфромации за играта

Кога ќе се појави играта на екран корисникот може да избере да игра против компјутерот

или против некој свој пријател. Од кога ке ја заврши рундата, корисниците добиваат

известување за победникот на играта и соодветно се ажурира табелата со поени.

Ако сакаат корисниците да ги зачуваат своите досегашни поени и да продолжат со играта

тоа можат да го направат со тоа што ке го одберат копчето “Restart”. Но, ако после тоа

одберрат да играат во друг вид, (на пример ако променат од играње со пријател во играње

со комјутер)сите поени ќе бидат ресетирани и инфромациите во табелата со поени ке

бидат повторно ажурирани .

Ако го кликнат копчето “Reset”сите досегашни зачувани информации се бришат.

Во “Help”можат да видат како се игра играта а во “Settings” можат да одберат дали првин

ќе игра Х или О.

Правилата на играта се едноставни



Kорисникот избира во која форма ке ја започне играта

Корисникот поточно играчот 1 има предност со то што секогаш започнува прв

Корисникот треба да избере едно од полињата и да го одбележи со Х или со О.




Корисникот ако избере да игра против комјутерот, тој автоматски ги пополнува

плочките за Х/О соодвенто.

Ако против корисник играчите се чекаат еден со друг.

Играчот е победник кога ќе успее да добие 3 исти знаци во било која

насока(вертикално, хоризонтално, дијагонално, антидијагонално)

Копчето рестарт ја започнува играта без губење на предходно зачувани

информациии.


“Reset” ги брише сите информации.

Структура

1. Custom Buttons класата е креирана со цел да се зачува соодветна информација за

секоја од полињата во кое се запишуваат Х/О соодветно.

2.Во самата форма се изведува логиката и алгоритмот за избирање на полиња /

уништување на полиња од страна на комјутерот и на играчот.

3.

Кога играчот(играчите) избираат полиња, се проверува дали предходно биле зафатени со

помош на настанот од соодветното поле. Ако се слободни се исцртува соодвентиот симбил

со помош на функцијатаDrawXO() .

Кога корисникот игра против комјутерот и кога на корисникот ќе му заврши редот,

комјутерот автоматкси ја повикува својата функција computerMove(). Таа функција работи

така што комјутерот ги испробува сите можности и гледа дали може со кое било од

вметнувањата да победи, ако не успева тогаш гледа дали може да го спречи противникот

(корисникот во овој случај ) во неговата победа.

А, ако нема доволно иформации за ниту една од тие две го избира првото слободно поле.

Доколку пак играчот не игра со комјутер тогаш според секој клик и со проверка дали има

парен или непарен број на интеракции со полиљата се извршува проверката за кој е

победник

check() функцијата ги проверува сите можни комбинации да провери дали има победник со

тоа што гледа ако сите вредности на соседни три полињата припаѓаат на еден играч тогаш,

тој е победникот.

GUI

За претставување на матрицата за XO , како и за поени користев dataGridView.



Превземен код

Form1 :Превемено од stackoverflow.com, за панелот.

typeof(Panel).InvokeMember("DoubleBuffered", BindingFlags.SetProperty

| BindingFlags.Instance | BindingFlags.NonPublic, null,

racePanel, new object[] { true }); // Pr

/// <summary>

/// Не е превземен,но бидејќи не знаев да работам со панели имаше неколку кодови

според кои се водев како да го направам


private void tableLayoutPanel1\_Paint(object sender, PaintEventArgs e)

{

var table = (TableLayoutPanel)sender;

var g = e.Graphics;

var penColor = Color.Black;

var penWidth = 2;

for (int i = 1; i < table.RowCount; i++)

{

var y = table.GetRowHeights().Take(i).Sum();

g.DrawLine(new Pen(penColor, penWidth), 0, y, table.Width, y);

}

for (int i = 1; i < table.ColumnCount; i++)

{

var x = table.GetColumnWidths().Take(i).Sum();

g.DrawLine(new Pen(penColor, penWidth), x, 0, x, table.Height);

}

}

// Направен според повеќе кодови на интернет за пребарување на специфични елементи во

панелот

foreach (Control container in this.Controls)



{

if (container is Panel)

{

foreach (Control control in container.Controls)

{

if (control is Button button)

{

control.Enabled = false;

control.ForeColor = Color.Red;

control.BackColor = Color.Transparent;

}

}


